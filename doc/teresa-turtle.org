#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: teresa-turtle
#+author: William Henney
#+email: whenney@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport


* NGC 6210

** Basic data on NGC 6210
+ Coordinates
  + (RA, Dec) = (16 44 29.5195973292, +23 47 59.491267229) sexagesimal
  + (RA, Dec) = (251.122998321, 23.7998586853) degrees


** Weak lines in spectra
+ He II 6560.10
  + Clearly seen on slits that pass through core of nebula
  + Small velocity splitting of only +/- 10 km/s
+ C II 6578.15
  + Weaker than the He II, but extends to a bit larger radii
  + Slightly larger velocity splitting
  + Also has a night sky component
+ He I 5015.68
  + In the [O III] spectrum
  + I think this is really a line
  + But we also have some optical ghosts
    + 5002 - definitely a ghost
    + 4996

** Original data files
+ [[file:~/Dropbox/Papers/LL-Objects/NGC6210/]]


** Plan of action
+ [2/6] Follow what I did for the Owl Nebula
  1. [X] Add WCS to image+slits
  2. [X] Make a median image and then use it to get slit positions
  3. [ ] Flux calibration using the median image
  4. [ ] At same time find offsets along slit
  5. [ ] Add WCS info to PV images
  6. [ ] Construct spectral maps (with tetrablock algorithm)


** [2/2] Median image
CLOSED: [2019-05-28 Tue 08:56]
+ We need to add WCS info to all of them
  + [X] Use astrometry.net
+ Most are Ha + [N II] image + slit
+ ~spm165~ is just an image and is saturated
  + [ ] Fix it - it is wrapping around the integers to negative values, so we just have to add 65536 to the negative pixels
+ Some are [O III] images
+ Others are properly saturated, but one is deep enough to show the halo well
  + ~spm238~ although it has artefacts from the central star

*** DONE Astrometry of image+slit exposures
CLOSED: [2019-05-26 Sun 17:53]
**** First test with astrometry.net
+ Based on what I did with \sigma Ori in [[id:B5B60BC7-5392-4245-93D6-8D17A6B56E5E][WCS solution from command line astrometry.net tools]]
+ Need to find the right index files
  + ICRS coords: 251.1230, 23.7999
  + Annoyingly, this falls at boundary of HEALPIX tiles, so we need ~10~ and ~31~ for the small scales
  + I am just getting scales ~00~ \to ~04~, which covers 2 to 11 arcmin.  Since the FOV is only 5 arcmin, this should be more than enough
  + Downloading from http://data.astrometry.net/5000/
    + The ~00~ scales are the biggest and take 15 min each
  + Copied to [[file:~/Work/astrometry/data/][file:~/Work/astrometry/data/]]
  + What should plate scale be?
    + FOV is 6.5 arcmin from Meaburn:2003a
    + Image size is 1024 pixels in all that I looked at
    + 6.5 60 / 1024 = 0.381 so try the range 0.35 \to 0.4
  + Test command - run in Terminal for safety
    #+begin_src sh :dir ../data/imslit :eval no 
      D=~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015
      solve-field --ra 251.1230 --dec 23.7999 --radius 1.0 --scale-units arcsecperpix --scale-low 0.35 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' $D/spm0030o_b.fits 
    #+end_src
  + That worked, but it wrote output to Teresa's shared Dropbox folder
    + Fix it using ~--dir .~ option
    + Try again with ~0035~
    + That worked fine, although the alignment is not perfect
    + If this turns out to be a problem I could try one or more of the following
      1. [X] Use ~--no-tweak~ setting to avoid using SIP polynomial
         - *yes* - that worked much better
         - and there should not be much need for distortion correction since nebula is much smaller than CCD
         - We also need to add ~--overwrite~ option in order to re-do the same image
      2. Maybe increase ~--odds-to-solve~ (default 1e9)
      3. Maybe play with ~--code-tolerance~ or ~--pixel-error~ but I am not sure what these mean (need to read Lang:2010a more carefully).
**** Production run with astrometry.net
+ First, need to get a list of all the image+slit files
***** ~solve-astrometry-imslit.sh~
#+name: imslit-list-2015
+ spm0030
+ spm0035
+ spm0036
+ spm0041
+ spm0042
+ spm0047
+ spm0048
+ spm0053
+ spm0056
+ spm0061
+ spm0109
+ spm0114
+ spm0115
+ spm0120
+ spm0121
+ spm0123
+ spm0128
+ spm0172
+ spm0177
+ spm0178
+ spm0183
+ spm0185
+ spm0190

Note that we need to use the ~${var[*]}~ syntax to access whole of array

#+header: :var files=imslit-list-2015
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 1.0 --scale-units arcsecperpix --scale-low 0.35 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/${f}o_b.fits
  done
#+end_src
***** ~solve-astrometry-imslit-failed.sh~
Some of these did not solve - see [[file:astrometry-imslit-2015.log]]

#+name: imslit-failed-2015
+ 0053
+ 0061
+ 0128
+ 0183
+ 0190

What do these have in common?
****** Try again with some modifications

Reduce required odds from 1e9 to 1e6

#+header: :var files=imslit-failed-2015
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-failed.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 1.0 --scale-units arcsecperpix --scale-low 0.35 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/spm${f}o_b.fits --odds-to-solve 1e6
  done
#+end_src

Some of these succeeded this time, and the solutions are totally fine
+ [X] 0053
+ 0061
+ 0128
+ 0183
+ [X] 0190

Reduce required odds still further

+ [X] 0061 (worked with 1e3)
+ [X] 0183 (worked with 30)
+ [X] 0128 (finally with 15, and increasing ~code-tol~ from 0.01 to 0.03)


#+name: imslit-stubborn-2015
+ 0128

#+header: :var files=imslit-stubborn-2015
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-stubborn.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 0.1 --scale-units arcsecperpix --scale-low 0.35 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/spm${f}o_b.fits --odds-to-solve 15 --quad-size-min 0.03 --code-tol 0.03 -v
  done
#+end_src


****** Example of successful run
#+begin_example
  Reading input file 1 of 1: "/Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0030o_b.fits"...
  Extracting sources...
  simplexy: found 44 sources.
  Solving...
  system: No such file or directory
  engine.c:79:engine_autoindex_search_paths: Warning: failed to open index directory: "/usr/local/Cellar/astrometry-net/0.76_2/data"

  Reading file "./spm0030o_b.axy"...
  Only searching for solutions within 1 degrees of RA,Dec (251.123,23.7999)
    log-odds ratio 31.3066 (3.94724e+13), 19 match, 1 conflict, 20 distractors, 71 index.
    RA,Dec = (251.122,23.7979), pixel scale 0.35018 arcsec/pix.
    Hit/miss:   Hit/miss: -++++--+--+c---++--+-+--++-+----+-+++-++(best)++++
  Field 1: solved with index index-5000-10.fits.
  Field 1 solved: writing to file ./spm0030o_b.solved to indicate this.
  Field: /Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0030o_b.fits
  Field center: (RA,Dec) = (251.121851, 23.797830) deg.
  Field center: (RA H:M:S, Dec D:M:S) = (16:44:29.244, +23:47:52.188).
  Field size: 5.51533 x 5.92387 arcminutes
  Field rotation angle: up is -87.8426 degrees E of N
  Field parity: pos
  Creating new FITS file "./spm0030o_b-wcs.fits"...
  Creating index object overlay plot...
  Creating annotation plot...
  Your field contains:
    NGC 6210
#+end_example
****** Examples of failed runs
******* 0053
#+begin_example
  Reading input file 1 of 1: "/Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0053o_b.fits"...
  Extracting sources...
  simplexy: found 46 sources.
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:25: RuntimeWarning: divide by zero encountered in log
    logpoisson = k*np.log(mean) - mean - np.array([sum(np.arange(kk)) for kk in k])
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:25: RuntimeWarning: invalid value encountered in multiply
    logpoisson = k*np.log(mean) - mean - np.array([sum(np.arange(kk)) for kk in k])
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:26: RuntimeWarning: invalid value encountered in less
    badbins = occupied[logpoisson < logcut]
  Solving...
  system: No such file or directory
  engine.c:79:engine_autoindex_search_paths: Warning: failed to open index directory: "/usr/local/Cellar/astrometry-net/0.76_2/data"

  Reading file "./spm0053o_b.axy"...
  Only searching for solutions within 1 degrees of RA,Dec (251.123,23.7999)
  Field 1 did not solve (index index-5000-10.fits).
  Field: /Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0053o_b.fits
  Did not solve (or no WCS file was written).
#+end_example
******* 0061
#+begin_example
  Reading input file 1 of 1: "/Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0061o_b.fits"...
  Extracting sources...
  simplexy: found 51 sources.
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:25: RuntimeWarning: divide by zero encountered in log
    logpoisson = k*np.log(mean) - mean - np.array([sum(np.arange(kk)) for kk in k])
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:25: RuntimeWarning: invalid value encountered in multiply
    logpoisson = k*np.log(mean) - mean - np.array([sum(np.arange(kk)) for kk in k])
  /usr/local/Cellar/astrometry-net/0.76_2/libexec/lib/python3.7/site-packages/astrometry/util/removelines.py:26: RuntimeWarning: invalid value encountered in less
    badbins = occupied[logpoisson < logcut]
  Solving...
  system: No such file or directory
  engine.c:79:engine_autoindex_search_paths: Warning: failed to open index directory: "/usr/local/Cellar/astrometry-net/0.76_2/data"

  Reading file "./spm0061o_b.axy"...
  Only searching for solutions within 1 degrees of RA,Dec (251.123,23.7999)
  Field 1 did not solve (index index-5000-10.fits).
  Field: /Users/will/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/spm0061o_b.fits
  Did not solve (or no WCS file was written).
#+end_example
***** ~solve-astrometry-imslit-missing.sh~
And some were missing 

#+name: imslit-missing-2015
+ 0042
+ 0047

#+header: :var files=imslit-missing-2015
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-missing.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 1.0 --scale-units arcsecperpix --scale-low 0.35 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/spm${f}o_b.fits
  done
#+end_src

Missing ones now got from Tere, and they worked
***** ~solve-astrometry-imslit-varias.sh~

#+name: imslit-list-varias
+ obj1002_bcr 
+ obj1006_bcr 
+ obj1009_bcr 
+ obj1012_bcr 
+ obj1017_bcr 
+ spm110_u
+ spm115_bcr 
+ spm118_bcr 
+ spm121_bcr 
+ spm124_bcr 
+ spm127_bcr 
+ spm134_bcr 
+ spm165_bcr 
+ spm223_bcr 
+ spm229_bcr 
+ spm318_bcr 
+ spm328_bcr 
+ spm331_bcr 
+ spm414_bcr 
+ spm236_bcr 
+ spm238_bcr 
+ spm242_bcr 
+ spm251_bcr 
+ spm256_bcr 
+ spm293_bcr 
+ spm296_bcr 
+ spm302_bcr 
+ spm303_bcr 
+ spm305_bcr 
+ spm306_bcr 
+ spm350_bcr 
+ spm358_bcr 
+ spm407_bcr
+ spm111_bcr
+ spm116_bcr
+ spm003_b
+ spm004_b
+ spm017_b

These have 512x512 arrays, so image pixels are bigger.  Use all the loose tolerances from the start

#+header: :var files=imslit-list-varias
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-varias.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Varias-temporadas
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 0.1 --scale-units arcsecperpix --scale-low 0.5 --scale-high 0.8 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/${f}.fits --odds-to-solve 1e6 --quad-size-min 0.01 --code-tol 0.03
  done
#+end_src

Six failed with the more stringent limits.  Three we will try with looser limits

#+name: imslit-failed-varias
+ obj1002_bcr
+ obj1006_bcr
+ spm293_bcr
#+header: :var files=imslit-failed-varias
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-varias-failed.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Varias-temporadas
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 0.1 --scale-units arcsecperpix --scale-low 0.5 --scale-high 0.8 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/${f}.fits --odds-to-solve 1e3 --quad-size-min 0.01 --code-tol 0.03
  done
#+end_src


But with 4 it is because the plate scale is smaller
#+name: imslit-1024-varias
+ spm003_b
+ spm004_b
+ spm017_b
+ spm019_b
+ spm021_b
+ spm111_cr
#+header: :var files=imslit-1024-varias
#+begin_src sh :tangle ../scripts/solve-astrometry-imslit-varias-1024.sh :eval no
  D=~/Dropbox/Papers/LL-Objects/NGC6210/Varias-temporadas
  for f in ${files[*]}; do
      solve-field --ra 251.1230 --dec 23.7999 --radius 0.1 --scale-units arcsecperpix --scale-low 0.3 --scale-high 0.4 --dir . --new-fits '%s-wcs.fits' --no-tweak --overwrite $D/${f}.fits --odds-to-solve 1e6 --quad-size-min 0.03 --code-tol 0.01
  done
#+end_src
*** DONE Combining the image + slits
CLOSED: [2019-05-28 Tue 08:57]
+ We do this separately for [O III] and Ha+[N II]
+ [4/4] Steps
  1. [X] Make a common grid for all images
     + Try 0.3 arcsec pixels and 512x512
  2. [X] Then scale all to a common min/max
     - This and the previous step are done in [[id:4FA9561B-6694-4D6F-98DE-320EB1FEAB0E][Re-gridding images]]
     - We use the median of top-right corner (slice: [420:, 420:]) for the background
     - We use the median of the central 18x18 arcsec portion (slice: [230:290, 230:290]) for the normalization
     - Final pixel values range up to about 10
  3. [X] Calculate median image
     - This is done in [[id:E0D99541-C96F-4927-8809-7912F10CB724][Combining into median image and divide by it]]
  4. [X] And take ratio of each individual to the median
+ Unfortunately, although this worked, the results are not very pretty
  + It will be difficult to automatically find the slits
  + Maybe I should use Teresa's results (/no, not necessary - now I have found slit positions by hand/)
**** Re-gridding images
:PROPERTIES:
:ID:       4FA9561B-6694-4D6F-98DE-320EB1FEAB0E
:END:

This should be run from top-level folder

#+header: :var tab=pos-ha
#+begin_src python :tangle ../scripts/regrid-images-ha.py :colnames no 
  import numpy as np
  from scipy.interpolate import griddata
  from astropy.io import fits
  from astropy.wcs import WCS
  from astropy.table import Table
  #
  # First set up WCS for the output image
  # We use capital letters for the output variables
  #

  NX, NY = 512, 512
  # 0.5 arcsec pixels
  dRA, dDec = -0.3/3600., 0.3/3600.
  # Center on central star of NGC 6210
  RA0, Dec0 = 251.122998321, 23.7998586853
  W = WCS(naxis=2)
  W.wcs.cdelt = [dRA, dDec]
  W.wcs.crpix = [0.5*(1 + NX), 0.5*(1 + NY)]
  W.wcs.crval = [RA0, Dec0]
  W.wcs.ctype = ['RA---TAN', 'DEC--TAN']

  outimage = np.zeros((NY, NX))
  # Create world coord arrays for output image
  II, JJ = np.meshgrid(np.arange(NX), np.arange(NY))
  RA, Dec = W.all_pix2world(II, JJ, 0)

  #
  # Read in the list of slits
  #
  table = Table(rows=tab[1:], names=tab[0])

  for i, row in enumerate(table):
      hdu, = fits.open(f"data/imslit/{row['imslit']}-wcs.fits")
      # image = (hdu.data - row['bias']) / (row['core'] - row['bias'])
      image = hdu.data
      outfilename = f'data/imslit-ha/imslit-{i:02d}.fits'
      ny, nx = image.shape
      #hdu.header.remove('@EPOCH')
      w = WCS(hdu.header)
      # Create world coord arrays for input image
      ii, jj = np.meshgrid(np.arange(nx), np.arange(ny))
      ra, dec = w.all_pix2world(ii, jj, 0)
      # Do the interpolation
      points = np.array(list(zip(ra.ravel(), dec.ravel())))
      xi = np.array(list(zip(RA.ravel(), Dec.ravel())))
      outimage = griddata(points, image.ravel(), xi, method='nearest').reshape((NY, NX))
      bg = np.nanmedian(outimage[420:, 420:])
      core = np.nanmedian(outimage[230:290, 230:290])
      print(core, bg)
      outimage = (outimage - bg)/(core - bg)
      # Save the output image
      fits.PrimaryHDU(header=W.to_header(), data=outimage).writeto(outfilename, overwrite=True)




#+end_src


#+header: :var tab=pos-oiii
#+begin_src python :tangle ../scripts/regrid-images-oiii.py :colnames no 
  import numpy as np
  from scipy.interpolate import griddata
  from astropy.io import fits
  from astropy.wcs import WCS
  from astropy.table import Table


  #
  # First set up WCS for the output image
  # We use capital letters for the output variables
  #

  NX, NY = 512, 512
  # 0.5 arcsec pixels
  dRA, dDec = -0.3/3600., 0.3/3600.
  # Center on central star of NGC 6210
  RA0, Dec0 = 251.122998321, 23.7998586853
  W = WCS(naxis=2)
  W.wcs.cdelt = [dRA, dDec]
  W.wcs.crpix = [0.5*(1 + NX), 0.5*(1 + NY)]
  W.wcs.crval = [RA0, Dec0]
  W.wcs.ctype = ['RA---TAN', 'DEC--TAN']

  outimage = np.zeros((NY, NX))
  # Create world coord arrays for output image
  II, JJ = np.meshgrid(np.arange(NX), np.arange(NY))
  RA, Dec = W.all_pix2world(II, JJ, 0)

  #
  # Read in the list of slits
  #
  table = Table(rows=tab[1:], names=tab[0])

  for i, row in enumerate(table):
      hdu, = fits.open(f"data/imslit/{row['imslit']}-wcs.fits")
      # image = (hdu.data - row['bias']) / (row['core'] - row['bias'])
      image = hdu.data
      outfilename = f'data/imslit-oiii/imslit-{i:02d}.fits'
      ny, nx = image.shape
      #hdu.header.remove('@EPOCH')
      w = WCS(hdu.header)
      # Create world coord arrays for input image
      ii, jj = np.meshgrid(np.arange(nx), np.arange(ny))
      ra, dec = w.all_pix2world(ii, jj, 0)
      # Do the interpolation
      points = np.array(list(zip(ra.ravel(), dec.ravel())))
      xi = np.array(list(zip(RA.ravel(), Dec.ravel())))
      outimage = griddata(points, image.ravel(), xi, method='nearest').reshape((NY, NX))
      bg = np.nanmedian(outimage[420:, 420:])
      core = np.nanmedian(outimage[230:290, 230:290])
      print(core, bg)
      outimage = (outimage - bg)/(core - bg)
      # Save the output image
      fits.PrimaryHDU(header=W.to_header(), data=outimage).writeto(outfilename, overwrite=True)

#+end_src
**** Combining into median image and divide by it
:PROPERTIES:
:ID:       E0D99541-C96F-4927-8809-7912F10CB724
:END:
#+BEGIN_SRC python :eval no :tangle ../scripts/medianize_images.py
  import sys
  import os
  import glob
  import numpy as np
  from astropy.io import fits

  try:
      datapath = sys.argv[1]
      fnlist = glob.glob(f"{datapath}/imslit-??.fits")
  except:
      sys.exit(f"Usage: {sys.argv[0]} DATAPATH")

  imlist = []
  for fitsname in fnlist:
      hdu, = fits.open(fitsname)
      imlist.append(hdu.data)
  imstack = np.dstack(imlist)
  median = np.median(imstack, axis=-1)
  fits.PrimaryHDU(header=hdu.header,
                  data=median).writeto(f'{datapath}/imslit-median.fits', overwrite=True)

  ratcombo = np.zeros_like(median)
  combo = np.zeros_like(median)
  for im, fn in zip(imlist, fnlist):
      combo = combo + im
      head, tail = os.path.split(fn)
      outname = os.path.join(head, tail.replace('imslit', 'imslit-ratio'))
      ratio = im/median
      ratcombo = ratcombo + ratio
      fits.PrimaryHDU(header=hdu.header,
                      data=ratio).writeto(outname, overwrite=True)
  fits.PrimaryHDU(header=hdu.header,
                  data=ratcombo).writeto(f'{datapath}/imslit-ratcombo.fits',
                                         overwrite=True)
  fits.PrimaryHDU(header=hdu.header,
                  data=combo).writeto(f'{datapath}/imslit-combo.fits',
                                      overwrite=True)

#+END_SRC

**** H\alpha + [N II] positions
:PROPERTIES:
:ID:       BE8A01A9-0999-44B5-8A51-E8E4B37960F9
:END:
+ 30 positions in total
+ ~wa = 1~ wavelength is first axis (fits order) in PV spec
+ ~wa = 2~ wavelength is second axis (fits order) in PV spec
+ ~ij = 1~ slit is vertical in I+S, so ~islit~ is along x-axis
+ ~ij = 2~ slit is horizontal in I+S, so ~islit~ is along y-axis
+ ~s = -1~ means that slit axis in I+S is reversed with respect to PV image
+ *Note*
  - spm0172o_b is clearly at an angle to the image axis (of 0.5 deg)

#+name: pos-ha
| spec          | imslit      |     run |    t | wa | islit | ij |  s |
|---------------+-------------+---------+------+----+-------+----+----|
| obj1003_bcrx  | obj1002_bcr | 1998-06 |   60 |  1 |   390 |  1 |  1 |
| obj1007_bcrx  | obj1006_bcr | 1998-06 |  300 |  1 |   388 |  1 |  1 |
| obj1010_bcrx  | obj1009_bcr | 1998-06 | 1200 |  1 |   388 |  1 |  1 |
| obj1015_bcrx  | obj1012_bcr | 1998-06 | 1200 |  1 | 390.5 |  1 |  1 |
| obj1018_bcrx  | obj1017_bcr | 1998-06 | 1200 |  1 | 390.5 |  1 |  1 |
| spm112_bcrx   | spm110_u    | 2003-06 | 1800 |  1 |   257 |  1 |  1 |
| spm116_bcrx   | spm115_bcr  | 2003-06 | 1800 |  1 |   263 |  1 |  1 |
| spm119_bcrx   | spm118_bcr  | 2003-06 | 1800 |  1 |   265 |  1 |  1 |
| spm122_bcrx   | spm121_bcr  | 2003-06 | 1800 |  1 |   267 |  1 |  1 |
| spm125_bcrx   | spm124_bcr  | 2003-06 | 1800 |  1 | 269.5 |  1 |  1 |
| spm130_bcrx   | spm127_bcr  | 2003-06 | 1800 |  1 | 272.5 |  1 |  1 |
| spm135_bcrx   | spm134_bcr  | 2003-06 | 1800 |  1 | 277.5 |  1 |  1 |
| spm224_bcrx   | spm223_bcr  | 2003-10 | 1800 |  1 | 294.5 |  1 |  1 |
| spm230_bcrx   | spm229_bcr  | 2003-10 | 1800 |  1 | 294.5 |  1 |  1 |
| spm329_bcrx   | spm328_bcr  | 2003-10 | 1800 |  1 |   273 |  1 |  1 |
| spm112-2_bcrx | spm111_cr   | 2011-05 | 1800 |  2 |   531 |  2 |  1 |
| spm018-bcrx   | spm017_b    | 2013-07 | 1800 |  1 |   505 |  2 | -1 |
| spm020-bcrx   | spm019_b    | 2013-07 | 1800 |  1 |   483 |  2 | -1 |
| spm023-bcrx   | spm021_b    | 2013-07 | 1800 |  1 |   496 |  2 | -1 |
| spm0031o_bcrx | spm0030o_b  | 2015-08 |  900 |  2 |   485 |  2 |  1 |
| spm0037o_bcrx | spm0036o_b  | 2015-08 |  900 |  2 |   484 |  2 |  1 |
| spm0043o_bcrx | spm0042o_b  | 2015-08 |  900 |  2 |   481 |  2 |  1 |
| spm0049o_bcrx | spm0048o_b  | 2015-08 |  900 |  2 |   480 |  2 |  1 |
| spm0057o_bcrx | spm0056o_b  | 2015-08 |  900 |  2 |   476 |  2 |  1 |
| spm0110o_bcrx | spm0109o_b  | 2015-08 | 1200 |  2 | 490.5 |  2 |  1 |
| spm0116o_bcrx | spm0115o_b  | 2015-08 | 1800 |  2 | 485.5 |  2 |  1 |
| spm0124o_bcrx | spm0123o_b  | 2015-08 | 1200 |  2 |   478 |  2 |  1 |
| spm0173o_bcrx | spm0172o_b  | 2015-08 |  900 |  2 |   493 |  2 |  1 |
| spm0179o_bcrx | spm0178o_b  | 2015-08 | 1800 |  2 | 489.5 |  2 |  1 |
| spm0186o_bcrx | spm0185o_b  | 2015-08 | 1800 |  2 | 515.5 |  2 |  1 |
**** [O III] positions

#+name: pos-oiii
| spec    | imslit     |     run |    t | wa | islit | ij |
|---------+------------+---------+------+----+-------+----|
| spm244  | spm242_bcr | 2004-06 | 1800 |  1 |   275 |  1 |
| spm253  | spm251_bcr | 2004-06 | 1800 |  1 |   280 |  1 |
| spm258  | spm256_bcr | 2004-06 | 1800 |  1 |   285 |  1 |
| spm294  | spm293_bcr | 2004-06 | 1800 |  1 |   262 |  1 |
| spm297  | spm296_bcr | 2004-06 | 1800 |  1 |   265 |  1 |
| spm114  | spm115_bcr | 2011-05 |  600 |  2 | 263.5 |  1 |
| spm0033 | spm0035o_b | 2015-08 |  900 |  2 |   485 |  2 |
| spm0039 | spm0041o_b | 2015-08 |  900 |  2 |   482 |  2 |
| spm0045 | spm0047o_b | 2015-08 |  900 |  2 |   479 |  2 |
| spm0051 | spm0053o_b | 2015-08 |  900 |  2 |   476 |  2 |
| spm0059 | spm0061o_b | 2015-08 |  900 |  2 |   475 |  2 |
| spm0112 | spm0114o_b | 2015-08 | 1200 |  2 |   486 |  2 |
| spm0118 | spm0120o_b | 2015-08 | 1800 |  2 | 479.5 |  2 |
| spm0126 | spm0128o_b | 2015-08 | 1200 |  2 | 476.5 |  2 |
| spm0175 | spm0177o_b | 2015-08 |  900 |  2 | 489.5 |  2 |
| spm0181 | spm0183o_b | 2015-08 | 1800 |  2 |   482 |  2 |
| spm0188 | spm0190o_b | 2015-08 | 1800 |  2 |   512 |  2 |

**** [O III] short exposures
| spec       | imslit |     run |   t | wa | islit | ij |
|------------+--------+---------+-----+----+-------+----|
| spm243-244 | spm242 | 2004-06 | 120 |  1 |   275 |  1 |
| spm252     | spm251 | 2004-06 | 120 |  1 |   280 |  1 |
| spm257     | spm256 | 2004-06 | 120 |  1 |   285 |  1 |
|            |        |         |     |    |       |    |
**** [S II] exposure
| spec   | imslit |     run |    t | wa | islit | ij |
|--------+--------+---------+------+----+-------+----|
| spm408 | spm407 | 2004-06 | 1800 |  1 |   269 |  1 |
**** Write tables to files for later use

First the H\alpha slits

#+name: save-slit-table
#+begin_src python :results file :return path :colnames no :var INTAB=pos-ha FN="ha-slits.tab"
  from astropy.table import Table
  path = f"../data/{FN}"
  Table(rows=INTAB[1:], names=INTAB[0]).write(path, format="ascii.tab")
#+end_src

#+RESULTS: save-slit-table
[[file:../data/ha-slits.tab]]

Second, the [O III] slits

#+call: save-slit-table(pos-oiii, "oiii-slits.tab")

#+RESULTS:
[[file:../data/oiii-slits.tab]]

** [1/1] Relative photometric calibration of the slits
*** DONE Obtain reference profiles from the median image
CLOSED: [2019-05-31 Fri 13:43]
+ [2/2] Steps
  1. [X] Find position of slit on median image
     - ~islit~ from the [[id:BE8A01A9-0999-44B5-8A51-E8E4B37960F9][H\alpha + {N II} positions]] table gives the pixel position perpendicular to slit (give or take a small tilt)
       - We have now written these to ascii files, such as [[file:~/Dropbox/Teresa-Turtle/data/ha-slits.tab]]
     - We can use the star (Ra, Dec) to find (i0, j0) pixel position for star
     - We then have a reference point on the slit (islit, j0), which is closest approach to the star
       - With small modification for ~ij = 2~ since then ~islit~ is in j-direction
  2. [X] With that info, we should be able to make a version of the ~find_slit_coords()~ function, as in the Owl project ([[id:4D50A4AB-80B1-4872-899F-8637EC758AB3][World coords from slit pixels]])
     - Do we even need the star position?
     - No, since we just get the world coords of all the pixels along the slit
*** Compare the slit profiles with the reference profiles
+ In the Owl project, everything was all lumped together, but I am going to do things in stages
+ We don't know what ~shift~ values to use between the im+slit and the PV image, so we will plot the profile comparisons first
+ And first, we will just do Ha + [N II]
+ We will probably have to do it several times, in order to get the ~shift~ values
+ We can have a first guess by collapsing down the image and PV and looking at the location of maximum

#+begin_src python :tangle ../scripts/compare-slit-profiles.py
  import os
  import sys
  import numpy as np
  import astropy
  from astropy.table import Table, Row, hstack
  from astropy.io import fits
  from astropy.wcs import WCS
  from astropy.wcs.utils import pixel_to_skycoord
  from astropy import units as u
  from astropy.coordinates import SkyCoord
  import seaborn as sns
  import turtle_utils
  from turtle_utils import (
      slit_profile,
      extract_full_profile_from_pv,
      extract_slit_profile_from_imslit,
      get_orig_folder,
      find_slit_coords,
      subtract_sky_and_trim,
      make_three_plots,
      extract_line_and_regularize,
      make_slit_wcs,
  )

  try:
      choice = int(sys.argv[1])
  except:
      choice = None

  restwavs = {'ha': 6562.79, 'nii': 6583.45, 'nii_s': 6548.05}

  # Position of star
  RA0, Dec0 = 251.122998321, 23.7998586853

  saturation = 6e4


  sns.set_palette('RdPu_d', 3)

  table1 = Table.read('data/ha-slits.tab', format="ascii.tab")
  table2 =  Table.read('data/align-ha.tab', format="ascii.tab")
  # The align-ha table takes precedence if islit has been modified
  table1.remove_column("islit")
  # We already have spec in the ha-slits table
  table2.remove_column("spec") 
  table = hstack([table1, table2], join_type="exact")



  # Photometric reference image
  photom, = fits.open('data/imslit-ha/imslit-median.fits')
  wphot = WCS(photom.header)
  turtle_utils.VERBOSE = 1
  neighbors = [-2, -1, 1, 2]
  for row in table:
      if choice is not None and row["id"] != choice:
          # If we asked for a single spectrum, then skip all others
          continue
      spec_hdu, = fits.open(get_orig_folder(row["run"]) + "/" + row["spec"] + ".fits")
      im_hdu, = fits.open("data/imslit/" + row["imslit"] + "-wcs.fits")
      # Mask out saturated pixels with NaN
      spec_hdu.data[spec_hdu.data > saturation] = np.nan
      # trim the edge or arrays since sometimes the outer pixels contain garbage
      spec_hdu.data = subtract_sky_and_trim(spec_hdu.data, row)
      spec_profile = extract_full_profile_from_pv(
          spec_hdu,
          wavaxis=row["wa"],
          bandwidth=90.0,
          linedict=restwavs)
      imslit_profile = extract_slit_profile_from_imslit(im_hdu.data, row)
      print(row)
      jslit = np.arange(len(spec_profile))
      # jslit0_spec = np.average(jslit, weights=spec_profile)
      # jslit0_imslit = np.average(jslit, weights=imslit_profile)
      # jslit0_spec = np.nanargmax(spec_profile)
      # jslit0_imslit = np.nanargmax(imslit_profile)
      jslit0_spec = row["j0_s"]
      jslit0_imslit = row["j0_i"]
      print(jslit0_spec, jslit0_imslit, 'shift =', row["shift"])
      slit_coords = find_slit_coords(row, im_hdu.header, spec_hdu.header)
      calib_profile = slit_profile(slit_coords['RA'], slit_coords['Dec'],
                                   photom.data, wphot)


      # Look at neighboring slit positions
      nb_calib_profiles = {}
      for nb in neighbors:
          nbrow = Table(row)[0]   # This is the trick to get a copy of the row
          nbrow["islit"] += nb
          nb_slit_coords = find_slit_coords(nbrow, im_hdu.header, spec_hdu.header)
          nb_calib_profiles[nb] = slit_profile(
              nb_slit_coords['RA'], nb_slit_coords['Dec'], photom.data, wphot)


      # Offset in arcsec along the slit
      slit_points = (np.arange(len(spec_profile)) - jslit0_spec)*slit_coords["ds"]
      # Extra correction for optical halos that show up at +/- 40 arcsec
      halo_mask = np.abs(np.abs(slit_points) - 40.0) < 10.0
      halo_correction = np.median(spec_profile[halo_mask])
      spec_profile -= halo_correction

      # Take a window about profile peak to normalize spec_profile
      jslice0 = slice(jslit0_spec-20, jslit0_spec+20)
      # propagate saturated pixels to the calibration profile
      calib_profile_nan = calib_profile.copy()
      calib_profile_nan[~np.isfinite(spec_profile)] = np.nan
      rat0 = np.nansum(spec_profile[jslice0])/np.nansum(calib_profile_nan[jslice0])
      print('Coarse calibration: ratio =', rat0)
      spec_profile /= rat0


      # Make a figure comparing the profiles
      plt_prefix = f"figs/{row.index:03d}-calib"
      ratio = make_three_plots(spec_profile, calib_profile, plt_prefix,
                               slit_points=slit_points,
                               neighbors=nb_calib_profiles, db=row, sdb=slit_coords)

      # Write out the flux-calibrated spectra
      spec_hdu.data -= halo_correction
      spec_hdu.data /= rat0
      save_prefix = f"data/pvextract/{row.index:03d}-{row['spec']}"
      # The default header has minimal changes from the original
      pvheader = fits.Header(spec_hdu.header, copy=True)

      for lineid, wav0 in restwavs.items():
          pvdata, contdata, wavs = extract_line_and_regularize(
              spec_hdu.data, WCS(spec_hdu.header), wav0, row)
          pvdata = pvdata[None, :, :]
          contdata = contdata[None, :, :]

          # Create a fancy WCS object for slit coordinates (and a simple one too)
          wslit, wsimp = make_slit_wcs(row, slit_coords, wavs, jslit0_spec)
          # Set the rest wavelength for this line
          wslit.wcs.restwav = (wav0*u.Angstrom).to(u.m).value
          pvheader.update(wsimp.to_header())
          pvheader.update(wslit.to_header(key='A'))
          pvheader['WEIGHT'] = rat0

          pvfile = f"{save_prefix}-{lineid}.fits"
          fits.PrimaryHDU(header=pvheader,
                          data=pvdata).writeto(pvfile, overwrite=True)
          fits.PrimaryHDU(header=pvheader,
                          data=contdata).writeto(pvfile.replace(".fits",
                                                                "-cont.fits"),
                                                 overwrite=True)
#+end_src

+ [X] How to deal with saturation?
  + Done with NaNs
+ Manual changes to alignment along-slit (j0) and across-slit (islit) 
  + 05 j0_i from 268 \to 273
    + Much better in core
  + 06 j0_i from 272 \to 274 AND islit from 263 \to 262
  + 09 j0_i 264 \to 266 AND islit 269.5 \to 268.5
    + Now almost perfect!
  + 12 j0_i 268 \to 264
    + Still not good
  + 13 j0_i 187 -> 190
  + 16 j0_i 644 \to 544
  + 17 j0_i \to 620 and invert sense of axis AND islit 483 \to 481.5
  + 18 j0_i 512 \to 492 (enormous shift) islit 496 \to 500
    + Still not great
  + 19, 20, 21 good near peak - bad in faint parts
  + 22 j0_i 446 \to 447
    + good near peak - bad in faint parts
  + 23 j0_i 448 \to 450 AND islit 476 \to 474
    + Pretty good on left side, but not on right
  + 24 good as is
  + 26 j0_i 544 \to 543 AND islit 478 \to 476
  + 27 j0_i 546 \to 536 AND islit 493 \to 492
    + Another nearly perfect one!


#+name: align-ha
| id | spec          | islit | j0_s |  j0_i | shift |
|----+---------------+-------+------+-------+-------|
| 00 | obj1003_bcrx  |   390 |  336 |   252 |    84 |
| 01 | obj1007_bcrx  |   388 |  325 |   243 |    82 |
| 02 | obj1010_bcrx  |   388 |  327 |   243 |    84 |
| 03 | obj1015_bcrx  | 390.5 |  335 |   254 |    81 |
| 04 | obj1018_bcrx  | 390.5 |  336 |   252 |    84 |
| 05 | spm112_bcrx   |   257 |  316 | 272.5 |  43.5 |
| 06 | spm116_bcrx   |   262 |  318 |   274 |    44 |
| 07 | spm119_bcrx   |   265 |  317 |   271 |    46 |
| 08 | spm122_bcrx   |   266 |  321 | 274.5 |  46.5 |
| 09 | spm125_bcrx   | 268.5 |  314 |   266 |    48 |
| 10 | spm130_bcrx   | 272.5 |  325 |   271 |    54 |
| 11 | spm135_bcrx   | 277.5 |  313 |   260 |    53 |
| 12 | spm224_bcrx   | 294.5 |  329 |   264 |    65 |
| 13 | spm230_bcrx   | 294.5 |  250 |   190 |    60 |
| 14 | spm329_bcrx   |   273 |  321 |   264 |    57 |
| 15 | spm112-2_bcrx |   531 |  509 |   589 |   -80 |
| 16 | spm018-bcrx   |   505 |  508 |   602 |   -94 |
| 17 | spm020-bcrx   | 481.5 |  529 |   622 |   -93 |
| 18 | spm023-bcrx   |   500 |  533 |   640 |  -107 |
| 19 | spm0031o_bcrx |   485 |  331 |   451 |  -120 |
| 20 | spm0037o_bcrx |   484 |  325 |   443 |  -118 |
| 21 | spm0043o_bcrx |   481 |  324 |   446 |  -122 |
| 22 | spm0049o_bcrx |   480 |  324 |   448 |  -124 |
| 23 | spm0057o_bcrx |   474 |  330 |   450 |  -120 |
| 24 | spm0110o_bcrx | 490.5 |  414 |   537 |  -123 |
| 25 | spm0116o_bcrx | 485.5 |  425 |   541 |  -116 |
| 26 | spm0124o_bcrx |   476 |  419 |   543 |  -124 |
| 27 | spm0173o_bcrx |   492 |  412 |   536 |  -124 |
| 28 | spm0179o_bcrx | 489.5 |  410 |   527 |  -117 |
| 29 | spm0186o_bcrx | 515.5 |  398 |   523 |  -125 |
#+TBLFM: $6=$4 - $5

#+call: save-slit-table(align-ha, "align-ha.tab")

#+RESULTS:
[[file:../data/align-ha.tab]]

**** TODO Refinements to the flux calibrations
+ [X] Faint slits: take into account that continuum bandwidth is 90\AA whereas I+S range is only 40\AA
  + This made no discernible difference
+ [X] Bright slits: take into account saturated pixels
  + Can spot them by looking at "Scale parameters" window in DS9
    + Peak in the pixel distribution around the saturation value
  + Saturated exposures
    |    |             |   Sat |  j1 |  j2 |
    |----+-------------+-------+-----+-----|
    | 05 | spm112_bcrx | 63000 | 309 | 322 |
    | 06 | spm116_bcrx | 63000 | 311 | 321 |
    | 08 | spm122_bcrx | 63000 | 317 | 325 |
    | 12 | spm224_bcrx | 63000 | 320 | 338 |
    | 13 | spm230_bcrx | 63000 | 240 | 258 |
    | 14 | spm329_bcrx | 63000 | 313 | 330 |
  + All are from 2003 with 1800 s exposures
+ [ ] Try to deal better with the halo rings  









** Utility functions
:PROPERTIES:
:header-args: :tangle ../scripts/turtle_utils.py
:ID:       60B2ED5C-7B49-4C33-9A59-EF1E7FBBDDDB
:END:

+ Mainly copied from the Owl Nebula's [[id:D65007F8-669F-441C-9FD5-3AEF8BEA4705][Utility functions]]
+ Do ~C-u C-u C-c C-v C-t~ to tangle all blocks into the module ~turtle_utils.py~ in the [[file:../scripts/]] folder


*** Imports
#+BEGIN_SRC python
import numpy as np
from astropy.wcs import WCS
from astropy.coordinates import SkyCoord
from astropy.wcs.utils import pixel_to_skycoord
from astropy import units as u
from astropy.modeling import models, fitting
from matplotlib import pyplot as plt
import seaborn as sns

VERBOSE = 0
#+END_SRC

*** Data paths
We assume that we are running in the top-level project folder file:../

#+begin_src python
  ORIG_DATA_ROOT = "../Papers/LL-Objects/NGC6210"

  def get_orig_folder(temporada):
      if "2015" in temporada:
          return ORIG_DATA_ROOT + "/Temporada2015"
      else:
          return  ORIG_DATA_ROOT + "/Varias-temporadas"


#+end_src

*** Synthetic slit from reference image: slit_profile()
+ Copied from [[id:28077E60-1BFE-4AD4-8DDE-5C292C252564][Construct the synthetic slit from the reference image]]
+ This uses nearest pixel algorithm - no interpolation at all
+ Slit pixels outside of the image are set to NaN 
#+BEGIN_SRC python
  def slit_profile(ra, dec, image, wcs):
      """
      Find the image intensity for a list of positions (ra and dec)
      """
      xi, yj = wcs.all_world2pix(ra, dec, 0)
      # Find nearest integer pixel
      ii, jj = np.floor(xi + 0.5).astype(int), np.floor(yj + 0.5).astype(int)
      if VERBOSE > 0:
          print(ra[::100], dec[::100])
          print(ii[::100], jj[::100])
      ny, nx = image.shape
      return np.array([image[j, i]
                       if (0 < i < nx and 0 < j < ny)
                       else np.nan
                       for i, j in list(zip(ii, jj))])


#+END_SRC


*** World coords from slit pixels: find_slit_coords()
+ This is based on the Owl Nebula version ([[id:4D50A4AB-80B1-4872-899F-8637EC758AB3][World coords from slit pixels]]) but with the following changes:
  1. ~wa~ applies to the PV image, and ~ij~ applies to the im+slit
     - In previous versions, ~saxis~ had been used for both (with opposite sense)
     - The sense is opposite to previously:
       - ~wa~ is the wavelength axis
       - ~ij~ is the CCD axis perpendicular to slit
  2. Check for case where on-chip binning is not specified in header (needed for 2003 data)
#+begin_src python
  def find_slit_coords(db, hdr, shdr):
      """Find the coordinates of all the pixels along a spectrograph slit

      Input arguments are a dict-like 'db' of hand-measured values (must
      contain 'wa', 'ij', islit' and 'shift') and a FITS headers 'hdr' from
      the image+slit exposure and 'shdr' from a spectrum exposure

      Returns a dict of 'ds' (slit pixel scale), 'PA' (slit position
      angle), 'RA' (array of RA values in degrees along slit), 'Dec'
      (array of Dec values in degrees along slit)

      """

      # Decide on axis order for both spectrum and image. Note that
      # values of 'wa' and 'ij' give the axis that is perpendicular to
      # the slit length (wavelength or position, respectively). Hence we
      # subtract from 3 to get the slit length axis
      jstring_i = str(3 - db['ij'])  # which image (I+S) axis lies along slit
      jstring_s = str(3 - db['wa'])  # which spec (pv) axis lies along slit

      dRA_arcsec = hdr['CD1_'+jstring_i]*3600*np.cos(np.radians(hdr['CRVAL2']))
      dDEC_arcsec = hdr['CD2_'+jstring_i]*3600
      ds = np.hypot(dRA_arcsec, dDEC_arcsec)
      PA = np.degrees(np.arctan2(dRA_arcsec, dDEC_arcsec)) % 360.0

      # Deal with parameters that depend on orientation of the PV image
      if jstring_s == '1':
          # PV slit has spatial axis horizontal in IMAGE coords
          ns = shdr['NAXIS1']
          # Mezcal has used two different ways of specifying on-chip binning
          try:
              # Older way
              spec_binning = shdr['CBIN']
          except KeyError:
              try:
                  # Newer way
                  spec_binning = shdr['CCDXBIN']
              except KeyError:
                  # And the very old data don't have it at all
                  spec_binning = 1
      elif jstring_s == '2':
          # PV slit has spatial axis vertical in IMAGE coords
          ns = shdr['NAXIS2']
          try:
              spec_binning = shdr['RBIN']
          except KeyError:
              try:
                  spec_binning = shdr['CCDYBIN']
              except KeyError:
                  spec_binning = 1
      else:
          raise ValueError('PV slit axis (3 - wa) must be 1 or 2')

      # Pixel coords of each slit pixel on image (in 0-based convention)
      # Deal with parameters that depend on orientation of the I+S image
      if jstring_i == '1':
          # Slit is horizontal in IMAGE coords
          iarr = np.arange(ns) - float(db['shift'])
          jarr = np.ones(ns)*float(db['islit'])
          # Mezcal has used two different ways of specifying on-chip binning
          try:
              # Older way
              image_binning = hdr['CBIN']
          except KeyError:
              try:
                  # Newer way
                  image_binning = hdr['CCDXBIN']
              except KeyError:
                  # And the very old data don't have it at all
                  image_binning = 1
          # correct for difference in binning between the image+slit and the spectrum
          iarr *= spec_binning/image_binning
      elif jstring_i == '2':
          # Slit is vertical in IMAGE coords
          iarr = np.ones(ns)*float(db['islit'])
          jarr = np.arange(ns) - float(db['shift'])
          try:
              image_binning = hdr['RBIN']
          except KeyError:
              try:
                  image_binning = hdr['CCDYBIN']
              except KeyError:
                  image_binning = 1
          jarr *= spec_binning/image_binning
      else:
          raise ValueError('I+S slit axis (3 - ij) must be 1 or 2')

      if db['s'] < 0:
          # Slit pixel axis has opposite sense in I+S and PV
          iarr = iarr[::-1]
          jarr = jarr[::-1]

      print('iarr =', iarr[::100], 'jarr =', jarr[::100])
      # Also correct the nominal slit plate scale
      ds *= spec_binning/image_binning

      # Convert to world coords, using the native frame
      w = WCS(hdr)
      observed_frame = w.wcs.radesys.lower()
      # Note it is vital to ensure the pix2world transformation returns
      # values in the order (RA, Dec), even if the image+slit may have
      # Dec first
      coords = SkyCoord(*w.all_pix2world(iarr, jarr, 0, ra_dec_order=True),
                        unit=(u.deg, u.deg), frame=observed_frame)
      print('coords =', coords[::100])
      print('Binning along slit: image =', image_binning, 'spectrum =', spec_binning)
      # Make sure to return the coords in the ICRS frame
      return {'ds': ds, 'PA': PA,
              'RA': coords.icrs.ra.value,
              'Dec': coords.icrs.dec.value}


#+end_src



*** Tidy up the PV image

+ Remove sky and extraneous border pixels

#+begin_src python
  def subtract_sky_and_trim(data, db, trim=3, margin=10):
      """Assume that pixels within `trim` of edge might be bad, and use
      average sky within margin of edge in spatial direction to define
      the bg
      """
      # convert axis notation from FITS to python convention
      wav_axis = 2 - db["wa"]
      if wav_axis == 0:
          bg = 0.5*(data[:, trim:margin] +
                    data[:, -margin:-trim]).mean(axis=1, keepdims=True)
      else:
          bg = 0.5*(data[trim:margin, :] +
                    data[-margin:-trim, :]).mean(axis=0, keepdims=True)
      # Remove sky background
      newdata = data - bg
      # And only then can we clean up the trim zone
      newdata[:trim, :] = 0.0
      newdata[-trim:, :] = 0.0
      newdata[:, :trim] = 0.0
      newdata[:, -trim:] = 0.0
      return newdata
#+end_src

*** Extract profile along PV slit
+ Add extra continuum since the filter is roughly twice as wide as can fit in the PV spectrum, for which we need:
  - ~bandwidth~ full filter width in angstrom
  - ~linewavs~ list of rest wavelengths of the lines so we know what to avoid
+ [ ] Also should deal with saturated pixels

#+begin_src python
  from astropy.constants import c



  def extract_full_profile_from_pv(spec_hdu, wavaxis, bandwidth, linedict):
      assert(wavaxis in [1, 2]) # wavaxis is in FITS convention
      w = WCS(spec_hdu.header)
      if wavaxis == 1:
          nwav = spec_hdu.header['NAXIS1']
          im = spec_hdu.data[:, :]
          wavs, _ = w.all_pix2world(np.arange(nwav), [0], 0)
      else:
          nwav = spec_hdu.header['NAXIS2']
          im = spec_hdu.data[:, :].T
          _, wavs = w.all_pix2world([0], np.arange(nwav), 0)

      # im should have wavelength as last axis (python convention)
      assert(nwav == im.shape[-1])

      wavmask = np.ones((nwav,)).astype(bool)
      # remove from continuum mask +/- 150 km/s around each line
      for lineid, wav0 in linedict.items():
          vels = 3e5*(wavs - wav0)/wav0
          wavmask = wavmask & (np.abs(vels) > 150.0)

      # broadcast to 2 dimensions
      imwts = np.ones_like(im)*wavmask[None, :]
      av_cont_profile = np.average(im, weights=imwts, axis=-1)
      # find how much extra continuum to add
      dwav = abs(wavs[1] - wavs[0])
      pv_bw = abs(wavs[-1] - wavs[0])
      missing_cont_profile = av_cont_profile*(bandwidth - pv_bw)/dwav
      # Add to the profile summed over the PV bandwidth
      full_profile = im.sum(axis=-1) + missing_cont_profile
      return full_profile


  def extract_slit_profile_from_imslit(data, db, slit_width=1):
      print(db["islit"])
      i1, i2 = int(db["islit"]) - slit_width, int(db["islit"]) + slit_width
      if db["ij"] == 1:
          return data[:, i1:i2].sum(axis=1)
      elif db["ij"] == 2:
          return data[i1:i2, :].sum(axis=0 )
      else:
          raise ValueError("ij must be 1 or 2")


#+end_src


*** Extract spectra for individual lines
+ These are heavily based on the Owl versions, but with changes due swapping ~saxis~ for ~wa~
#+begin_src python
  def extract_profile(data, wcs, wavrest, db, dw=7.0):
      """We don't use this any more"""
      data, bgdata = remove_bg_and_regularize(data, wcs, wavrest, db)
      # pixel limits for line extraction
      lineslice = wavs2slice([wavrest-dw/2, wavrest+dw/2], wcs, db)
      return data[:, lineslice].sum(axis=1), bgdata.sum(axis=1)


  def wavs2slice(wavs, wcs, db):
      """Convert a wavelength interval `wavs` (length-2 sequence) to a slice of the relevant axis`"""
      assert len(wavs) == 2
      isT = db['wa'] == 2
      if isT:
          _, xpixels = wcs.all_world2pix([0, 0], wavs, 0)
      else:
          xpixels, _ = wcs.all_world2pix(wavs, [0, 0], 0)
      print('Wav:', wavs, 'Pixel:', xpixels)
      i1, i2 = np.maximum(0, (xpixels+0.5).astype(int))
      return slice(min(i1, i2), max(i1, i2))


  def extract_line_and_regularize(data, wcs, wavrest, db,
                                  dw=10.0, dwbg_in=7.0, dwbg_out=10.0):
      '''
      Transpose data if necessary, and then subtract off the continuum
      (blue and red of line, inner width `dwbg_in`, outer width
      `dwbg_out`) and restrict to window (width `dw`) around line
      center.  Returns cont-subtracted PV array (2d), cont array (2d),
      and wavs array (1d)
      '''
      isT = db['wa'] == 2
      # Make sure array axis order is (position, wavelength)
      if isT:
          data = data.T
          nwav = wcs.pixel_shape[1]
          _, wavs = wcs.all_pix2world([0], np.arange(nwav), 0)
      else:
          nwav = wcs.pixel_shape[0]
          wavs, _ = wcs.all_pix2world(np.arange(nwav), [0], 0)

      # pixel limits for blue, red bg extraction
      bslice = wavs2slice([wavrest-dwbg_out/2, wavrest-dwbg_in/2], wcs, db)
      rslice = wavs2slice([wavrest+dwbg_in/2, wavrest+dwbg_out/2], wcs, db)
      # extract backgrounds on blue and red sides
      bgblu = data[:, bslice].mean(axis=1)
      bgred = data[:, rslice].mean(axis=1)
      # take weighted average, accounting for cases where the bg region
      # does not fit in the image
      weight_blu = data[:, bslice].size
      weight_red = data[:, rslice].size
      print('Background weights:', weight_blu, weight_red)
      bg = (bgblu*weight_blu + bgred*weight_red)/(weight_blu + weight_red)

      # pixel limits for entire window
      wslice = wavs2slice([wavrest-dw/2, wavrest+dw/2], wcs, db)
      # restrict to just this window
      data = data[:, wslice]
      # and actually subtract the continuum
      bgdata = np.zeros_like(data)
      bgdata += bg[:, None]

      return data - bgdata, bgdata, wavs[wslice]
#+end_src

#+RESULTS:
: None

*** Make WCS for the PV images
#+BEGIN_SRC python
  def make_slit_wcs(db, slit_coords, wavs, j0):

      #
      # First, wavelength axis, which is easy
      #
      dwav = wavs[1] - wavs[0]
      wav0 = wavs[0]
      wavpix0 = 1

      #
      # Second, find the displacement scale and ref point from the slit_coords
      #
      # The slit_coords should already be in ICRS frame
      c = SkyCoord(slit_coords['RA'], slit_coords['Dec'], unit=u.deg)
      # Find vector of separations between adjacent pixels
      seps = c[:-1].separation(c[1:])
      # Ditto for the position angles
      PAs = c[:-1].position_angle(c[1:])
      # Check that they are all the same as the first one
      assert(np.allclose(seps/seps[0], 1.0))
      # assert(np.allclose(PAs/PAs[0], 1.0, rtol=1.e-4))
      # Then use the first one as the slit pixel size and PA
      ds, PA, PA_deg = seps[0].deg, PAs.mean().rad, PAs.mean().deg
      # And for the reference values too
      RA0, Dec0 = c[0].ra.deg, c[0].dec.deg

      #
      # Now make a new shiny output WCS, constructed from scratch
      #
      w = WCS(naxis=3)

      # Make use of all the values that we calculated above
      w.wcs.crpix = [wavpix0, 1, 1]
      w.wcs.cdelt = [dwav, ds, ds]
      w.wcs.crval = [wav0, RA0, Dec0]
      # PC order is i_j = [[1_1, 1_2, 1_3], [2_1, 2_2, 2_3], [3_1, 3_2, 3_3]]
      w.wcs.pc = [[1.0, 0.0, 0.0],
                  [0.0, np.sin(PA), -np.cos(PA)],
                  [0.0, np.cos(PA), np.sin(PA)]]

      #
      # Finally add in auxillary info
      #
      w.wcs.radesys = 'ICRS'
      w.wcs.ctype = ['AWAV', 'RA---TAN', 'DEC--TAN']
      w.wcs.specsys = 'TOPOCENT'
      w.wcs.cunit = [u.Angstrom, u.deg, u.deg]
      w.wcs.name = 'TopoWav'
      w.wcs.cname = ['Observed air wavelength', 'Right Ascension', 'Declination']

      # Check the new pixel values
      npix = len(slit_coords['RA'])
      check_coords = pixel_to_skycoord(np.arange(npix), [0]*npix, w, 0)
      # These should be the same as the ICRS coords in slit_coords
      print('New coords:', check_coords[::100])
      print('Displacements in arcsec:', check_coords.separation(c).arcsec[::100])
      # 15 Sep 2015: They seem to be equal to within about 1e-2 arcsec

      #
      # And a simple version with slit offsets in arcsec
      #
      w2 = WCS(naxis=2)
      w2.wcs.crpix = [wavpix0, j0+1]
      w2.wcs.cdelt = [dwav, ds]
      w2.wcs.crval = [wav0, 0.0]
      w2.wcs.ctype = ['LINEAR', 'LINEAR']

      return w, w2
#+END_SRC
*** Fit Chebyshev polynomial
#+begin_src python
  def fit_cheb(x, y, npoly=3, mask=None):
      """Fits a Chebyshev poly to y(x) and returns fitted y-values"""
      fitter = fitting.LinearLSQFitter()
      p_init = models.Chebyshev1D(npoly, domain=[x.min(), x.max()])
      if mask is None:
          mask = np.ones_like(x).astype(bool)
      p = fitter(p_init, x[mask], y[mask])
      if VERBOSE > 0:
          print(p)
      return p(x)


#+end_src

*** Plot utilities
#+begin_src python
  def make_three_plots(spec, calib, prefix,
                       slit_points=None, niirat=None, neighbors=None, db=None, sdb=None):
      assert spec.shape == calib.shape
      fig, axes = plt.subplots(3, 1)

      if slit_points is None:
          ypix = np.arange(len(calib))
          xlabel = "Slit pixel"
          xlim = None
      else:
          ypix = slit_points
          xlabel = "Slit position, arcsec"
          xlim = -80, 80

      xlim = xlim or (ypix.min(), ypix.max())

      # vmax = np.percentile(calib, 95) + 2*calib.std()
      vmax = 20.0
      vmin = -0.01
      ratio = spec/calib

      alpha = 0.8

      # First, plot two profiles against each other to check for zero-point offsets
      # axes[0].plot(calib, spec/ratio_fit, '.', alpha=alpha)
      axes[0].plot(calib, spec, '.', alpha=alpha)
      axes[0].plot([vmin, vmax], [vmin, vmax], '-', alpha=alpha)
      axes[0].set_xlim(vmin, vmax)
      axes[0].set_ylim(vmin, vmax)
      axes[0].set_xlabel('Calibration Image')
      axes[0].set_ylabel('Uncorrected Integrated Spectrum')
      axes[0].set_xscale('symlog', linthreshx=0.01)
      axes[0].set_yscale('symlog', linthreshy=0.01)

      # Second, plot each against slit pixel to check spatial offset
      axes[1].plot(ypix, spec, alpha=alpha, lw=1,
                   label='Integrated Spectrum')
      axes[2].plot(ypix, spec/np.nanmax(calib), alpha=alpha, lw=1,
                   label='Integrated Spectrum')
      axes[1].plot(ypix, calib, alpha=alpha, label='Calibration Image')
      axes[2].plot(ypix, calib/np.nanmax(calib), alpha=alpha, label='Calibration Image')
      if neighbors is not None:
          for nb, calib_nb in neighbors.items():
              lw = 0.5 + 0.1*nb
              label = f"Slit $\Delta x = {nb:+1d}$"
              axes[1].plot(ypix, calib_nb,
                           alpha=0.3*alpha, lw=lw, color="k", label=label)
              axes[2].plot(ypix, calib_nb/np.nanmax(calib_nb),
                           alpha=0.3*alpha, lw=lw, color="k", label=label)
      # axes[1].plot(ypix, spec/ratio_fit, alpha=alpha, lw=1.0,
      #              label='Corrected Integrated Spectrum')
      axes[1].set_xlim(*xlim)
      axes[1].set_ylim(vmin, vmax)
      axes[1].legend(fontsize='xx-small', loc='upper right')
      axes[1].set_xlabel(xlabel)
      axes[1].set_ylabel('Profile (absolute log scale)')
      axes[1].set_yscale('symlog', linthreshy=0.01)

      # # Third, plot ratio to look for spatial trends
      # axes[2].plot(ypix, ratio, alpha=alpha)
      # axes[2].plot(ypix, ratio_fit, alpha=alpha)
      # if niirat is not None:
      #     axes[2].plot(ypix, niirat, 'b', lw=0.5, alpha=0.5)
      axes[2].set_xlim(-40, 40)
      axes[2].set_ylim(-0.05, 1.05)
      axes[2].set_xlabel(xlabel)
      # axes[2].set_ylabel('Ratio: Spec / Calib')
      axes[2].set_ylabel('Profile (relative linear scale)')

      info = ""
      if db is not None:
          # Add some info to the graphs
          info += fr"H$\alpha$ slit {db['id']:02d}" + "\n"
          info += f"PV: {db['spec']}" +"\n"
          info += f"I+S: {db['imslit']}" + "\n"
          info += f"Date: {db['run']}, t = {db['t']} s" + "\n"
      if sdb is not None:
          info += fr"Slit PA = ${sdb['PA']:.1f}^\circ$, ds = {sdb['ds']:.2f} arcsec" + "\n"
      if info:
          axes[0].text(0.95, 0.05, info,
                       fontsize="small",
                       ha="right", va="bottom", transform=axes[0].transAxes)
      fig.set_size_inches(5, 8)
      fig.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)
      fig.savefig(prefix+'.png', dpi=300)

      return None


#+end_src

#+RESULTS:
: None

* Teresa's tables
** H alpha
So, she has 11 positions missing
*** 2015 Ha (11 positions)
| #       |         RA |       Dec | dataset | helio corr |  NX |  NY | xpixscale | jcenter | ufiddle | fluxfiddle | "True File"          |
|---------+------------+-----------+---------+------------+-----+-----+-----------+---------+---------+------------+----------------------|
| east871 |    -0.8712 |   22.0212 |       1 |     -20.54 | 300 | 373 |     0.351 |     219 |       0 |         20 | spec0116-ha-inv.fits |
| east612 |    -0.7104 |   22.1004 |       1 |     -20.45 | 300 | 373 |     0.351 |     225 |       0 |         30 | spec0110-ha-inv.fits |
| east300 |       -0.3 |   -7.5708 |       1 |     -20.41 | 300 | 373 |     0.352 |     145 |       0 |          1 | spec0031-ha-inv.fits |
| east148 |     -0.096 |   -8.5932 |       1 |     -20.49 | 300 | 373 |     0.352 |     144 |       0 |          1 | spec0037-ha-inv.fits |
| west069 |     0.0696 |   -7.1784 |       1 |     -20.55 | 300 | 373 |     0.352 |     150 |       0 |          1 | spec0043-ha-inv.fits |
| west300 |        0.3 |   -6.6456 |       1 |     -20.59 | 300 | 373 |     0.352 |     150 |       0 |          1 | spec0049-ha-inv.fits |
| west492 |      0.492 |   -7.1532 |       1 |     -20.63 | 300 | 373 |     0.352 |     144 |       0 |          1 | spec0057-ha-inv.fits |
| west528 |      0.528 |   22.9752 |       1 |     -20.47 | 300 | 373 |     0.351 |     224 |       0 |          1 | spec0173-ha-inv.fits |
| west684 |      0.684 |   22.0284 |       1 |     -20.65 | 300 | 373 |     0.351 |     220 |       0 |          1 | spec0124-ha-inv.fits |
| west873 |     0.8736 |   21.0384 |       1 |     -20.55 | 300 | 373 |     0.351 |     215 |       0 |          1 | spec0179-ha-inv.fits |
| west120 |     1.2024 |   21.5748 |       1 |      -20.6 | 300 | 373 |     0.351 |     220 |       0 |          1 | spec0186-ha-inv.fits |

+ Imported from file:~/Dropbox/Papers/LL-Objects/NGC6210/Temporada2015/SPMha/star-ha.csv
+ Constant columns removed:
  + lamrest :: 6562.8
  + lam0 :: 6557
  + lamscale :: 0.043752133
  + d vel :: 2

*** 1998 \to 2013 Ha (8 positions)
| #       |      RA |       Dec | dataset | helio corr |  NX |  NY | ypixscale | jcenter | ufiddle | fluxfiddle | "True File"                   |
|---------+---------+-----------+---------+------------+-----+-----+-----------+---------+---------+------------+-------------------------------|
| east087 | -1.0968 |     -5.76 |       1 |      -3.23 | 300 | 101 |     0.624 |      55 |       0 |          1 | spec135-crop-ha.fits          |
| east040 | -0.6264 |   -10.476 |       1 |       -2.9 | 300 | 101 |     0.625 |      55 |       0 |          1 | spec119-crop-ha.fits          |
| east015 |  -0.372 |    -9.612 |       1 |      -2.84 | 300 | 101 |     0.626 |      55 |       0 |          1 | spec116-crop-ha.fits          |
| west005 |  -0.168 |     -9.72 |       1 |      -2.79 | 300 | 101 |     0.625 |      55 |       0 |          1 | spec112-crop-ha.fits          |
| west027 |  0.0432 |    19.404 |       2 |       2.44 | 300 | 101 |     0.351 |     130 |       0 |          1 | spec112-2crop-ha-binning.fits |
| west053 |  0.3048 |   -10.116 |       1 |      -2.97 | 300 | 101 |     0.625 |      55 |       0 |          1 | spec122-crop-ha.fits          |
| west084 |  0.6168 |    -9.612 |       1 |      -3.04 | 300 | 101 |     0.624 |      55 |       0 |          1 | spec125-crop-ha.fits          |
| west122 |  0.9936 |    -8.784 |       1 |      -3.17 | 300 | 101 |     0.623 |      55 |       0 |          1 | spec130-crop-ha.fits          |
